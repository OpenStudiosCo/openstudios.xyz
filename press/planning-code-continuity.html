<!DOCTYPE html>
<html>
  <head>
    <title>Planning for Code Continuity Across a Company | Press | Open Studios
    </title>
    <base href="/">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/semantic-ui/2.4.1/semantic.min.css" rel="stylesheet">
    <link href="./dist/styles.css" rel="stylesheet">
  </head>
  <body>
    <div id="wrapper">
      <div class="ui container">
        <div class="ui basic center aligned segment">
          <h2>Planning for Code Continuity Across a Company</h2>
          <p><strong>by Paul Brzeski</strong></p>
          <p><em>16th of March 2020</em></p>
          <div class="ui stackable two column grid">
            <div class="row">
              <div class="column">
                <p>Open Studios is currently a one man operation which presents a challenge to how work is done. I've built dozens of websites in Content Management Systems over the years and so my first decision was to avoid one. Maintaining the Kamigen and Open Studios websites with a CMS would have introduced countless problems including man-hour overheads as well as security, performance and architecture concerns. Those websites are instead built with Kettlefish, a custom static website generator that makes prototyping complex front-ends really easy (largely thanks to of Pug.JS and Semantic UI).</p>
                <p>Having also built and maintained a lot of software over the years - I was keen to avoid decisions that would require a lot of man hours to carry out. Manifold originally used Backbone and Underscore in order to accelerate development, in theory at least. As a bespoke, prototype driven project Manifold was challenging to write in an MVC context, much of the time generating redundant classes and spreading integrations and features across multiple folders instead of keeping them together.</p>
                <p>Currently the most popular front-end application frameworks are Angular, React and Vue.js - all require a significant amount of engineering work to implement, with little foreseeable benefit, so there is no plan to implement these frameworks for now. Not only has it been challenging to remove Backbone and Underscore from Manifold's architecture, features within modern Javascript such as modules and tree-shaking/bundling tools are all I need to implement complex and scaleable software architecture. </p>
                <p>Setting up services, databases, servers and other supplementary infrastructure is expensive on resources. It's trivial to spin up another feature or repository to power a server application but Open Studios simply does not require one at this point in time. All Open Studios websites and software are built on a decoupled frontend approach; generated from templates using Kettlefish with any server integrations being done purely at the JS application level. This approach ensures front-ends are nigh untouchable when it comes to optimal performance, security and maintenance; because the front-end and back-end concerns are separate, interrelated issues don't have to be solved together. In future, the development script within Kettlefish that watches for file changes, serves HTTP and generates new HTML/CSS/JS could easily be tweaked to act as a standalone web server.</p>
              </div>
              <div class="column"><img class="ui image medium" src="/assets/kamigenconcept.png"><em>Concept art of the Kamigen UI on mobile</em></div>
            </div>
            <div class="row">
              <div class="column">
                <p>Both Kamigen and Manifold are currently blocked in development by code architecture problems. Kamigen needs to be refactored to use the most recent patterns implemented in Langenium, currently it's still just one giant script file which makes it hard to extend and maintain. Manifold has a bit of MVC cruft left over, the new architecture that is emerging is incomplete and refactoring is yet to begin at the Pug template level. The Manifold UI certainly has some ways to go as well if it is to compete with the likes of Adobe Illustrator, Blender and Sketch.</p>
                <p>As Kamigen is already complex, I have dusted off a smaller game idea to refactor first. I am currently working on building up Rover, an arcade style cycling game. Once Rover is at a playable stage (pictured right), I will transfer the architectural learnings to Kamigen and potentially others projects including Manifold and hopefully Kettlefish (if something useful to all Kettlefish based projects is discovered).</p>
                <p>This integrative approach to software architecture has required patience and careful planning, but it has already been paying dividends for years. My websites are hosted on Github Pages for free and their lightweight nature allows me to focus on the users, putting additional time into the final testing and polishing stages of all the work facilitates a higher quality result. Facilitating enjoyment through quality is one of the most important things to get right in digital entertainment.</p>
              </div>
              <div class="column"><img class="ui image medium" src="/assets/roverconcept.png"><em>Concept art of the Rover UI and gameplay</em></div>
            </div>
            <div class="row">
              <div class="column">
                <div class="ui stackable two column grid">
                  <div class="row">
                    <div class="column">
                      <h3>Related Open Studios links</h3>
                      <ul>
                        <li><a href="https://kamigen.com">Kamigen website</a></li>
                        <li><a href="https://www.npmjs.com/package/kettlefish">Kettlefish on NPM</a></li>
                        <li><a href="https://paulbrzeski.com/case-studies/langenium.html">Langenium case study</a></li>
                        <li><a href="https://github.com/paulbrzeski/manifold">Manifold repository on Github</a></li>
                      </ul>
                    </div>
                    <div class="column">
                      <h3>External links</h3>
                      <ul>
                        <li><a href="https://backbonejs.org/">Backbone.JS</a></li>
                        <li><a href="https://pugjs.org/">Pug.JS</a></li>
                        <li><a href="https://semantic-ui.com/">Semantic UI</a></li>
                        <li><a href="https://underscorejs.org/">Underscore</a></li>
                      </ul>
                    </div>
                  </div>
                </div>
              </div>
              <div class="column"></div>
            </div>
          </div>
        </div>
      </div>
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/semantic-ui/2.4.1/semantic.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/110/three.js"></script>
    <script src="./dist/app.js"></script>
    <!-- Global site tag (gtag.js) - Google Analytics-->
    <script async="" src="https://www.googletagmanager.com/gtag/js?id=UA-155740430-1"></script>
    <script id="vs" type="not-js">
      void main() {
        gl_Position = vec4( position, 1.0 );
      }
    </script>
    <script id="fs" type="not-js">// Forked from: https://www.shadertoy.com/view/NsS3Dt

#extension GL_OES_standard_derivatives : enable

precision highp float;

uniform float time;
uniform vec2 mouse;
uniform vec2 resolution;

float hash12(vec2 p)
{
	vec3 p3  = fract(vec3(p.xyx) * .1031);
    p3 += dot(p3, p3.yzx + 33.33);
    return fract((p3.x + p3.y) * p3.z);
}

//----------------------------------------------------------------------------------------
//  2 out, 1 in...
vec2 hash21(float p)
{
	vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));
	p3 += dot(p3, p3.yzx + 33.33);
    return fract((p3.xx+p3.yz)*p3.zy);

}
float noise(vec2 p)
{
    vec2 ip = floor(p), fp = fract(p);
    fp = smoothstep(0.,1.,fp);
    return mix(
               mix(hash12(ip+vec2(0,0)), hash12(ip+vec2(1,0)), fp.x),
               mix(hash12(ip+vec2(0,1)), hash12(ip+vec2(1,1)), fp.x),
               fp.y);
}

float fbm(vec2 p, int lv)
{
    float a = 1.0;
    float t = 0.0;
    for( int i=0; i<8; i++ )
    {
        p += vec2(13.102,1.535);
        t += a*noise(p);
        p *= mat2(3,4,-4,3) * 0.4;
        a *= 0.5;
    }
    return 0.5*t;
}

void main( )
{
    vec2 uv = (2.*gl_FragCoord.xy-resolution.xy)/resolution.y;
    
    float mtHeight = fbm(uv.xx+0.6, 8);
    float mtHeightSm = fbm(uv.xx+0.6, 3);
    vec3 col = vec3(0);
    vec2 sunPos = vec2(0.8,-0.);
    vec3 skyCol = vec3(0.075,0.310,0.518);
    float q = uv.y-sunPos.y;
    float q2 = uv.x-sunPos.x;
    skyCol = mix(skyCol, vec3(0.482,0.580,0.902), exp(-0.5*q*q-0.2*q2*q2));
    vec3 cloudCol = mix(skyCol, vec3(0.5), 0.2);
    skyCol = mix(skyCol, vec3(0.706,0.851,0.953), exp(-q*q*3.-0.5*q2*q2));
    skyCol = mix(skyCol, vec3(0.980,0.5,0.3), exp(-q*q*10.-0.5*q2*q2));
    skyCol = mix(skyCol, vec3(1.0,1.0,0.7), exp(-3.*length(uv-sunPos)));
    vec3 cloudCol2 = mix(skyCol, vec3(0.5), 0.2);
    vec3 cloudCol3 = mix(vec3(0.980,0.5,0.3),vec3(1.0,1.0,0.7), exp(-length(uv-sunPos)));
    cloudCol3 = mix(cloudCol3, cloudCol, smoothstep(0.,-1.,uv.y+0.3*uv.x));
    
    float w = 1.5*length(fwidth(uv));
    float isSky = smoothstep(0.,w,uv.y+0.3*uv.x+0.2*max(uv.x,0.)+1.-mtHeight);
   
	col = mix(col, skyCol, isSky);
    col = mix(col, skyCol, 0.5*smoothstep(-0.5,0.1,uv.y+0.3*uv.x+0.2*max(uv.x,0.)+1.-mtHeightSm));
    
    vec2 fuv = fract(0.1*uv);
    vec2 uvv = 20.*fuv*(1.-fuv)*(0.5-fuv);
    uvv = vec2(1,-1)*uvv.yx;
    vec2 uv2 = uv + uvv*cos(0.4*time);// twisting
    
    float silver = fbm(30.*uv - 0.06*time, 8) + 30.*(uv.y + 0.8);
    silver = smoothstep(0.,1.,silver)*smoothstep(2.,1.,silver) * 1./(1.+500.*q2*q2) * isSky;
    col += silver * vec3(0.9,0.6,0.3) * 100.;
    
    
    float lowClouds = fbm(5.*uv + 0.1*time, 8);
    float midClouds = fbm(3.*uv + vec2(0.06,-0.03)*time, 8);
    float hiClouds = fbm(uv2 + vec2(0.1,0.01)*time, 8) - 0.5;
    float hiClouds2 = fbm(uv + 10. + vec2(0.062,-0.03)*time, 8) - 0.5;
    col = mix(col, cloudCol3, 0.5*smoothstep(0.,1., -uv.y+3.*hiClouds));
    col = mix(col, cloudCol3, 0.5*smoothstep(0.,1., -uv.y+3.*hiClouds2));
    col = mix(col, vec3(0.9,0.6,0.3) * 100., 1./(1.+2000.*(q*q+q2*q2)));
    col += vec3(0.9,0.6,0.3) * 2./(1.+10.*sqrt(q*q+0.3*q2*q2));
    col = mix(col, 0.8*cloudCol, 0.8*smoothstep(0.,1., -2.*(uv.y+0.5)+midClouds));
    col = mix(col, 0.5*cloudCol, smoothstep(0.,1., -3.*(uv.y+0.8)+lowClouds));
    
    
    col = mix(col, col*pow(col/(col.r+col.g+col.b), vec3(dot(uv,uv)*0.3)), 0.2); // vignette
    col = pow(col, vec3(2.2));
    col = (col*(2.51*col+0.03))/(col*(2.43*col+0.59)+0.14); // tonemapping
    col = pow(col, vec3(1./2.2));
    
    col += 0.03 * (hash12(gl_FragCoord.xy)-0.5) * sqrt(resolution.y/400.);

    // Output to screen
    gl_FragColor = vec4(col,1.0);
}

    </script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'UA-155740430-1');
    </script>
  </body>
</html>